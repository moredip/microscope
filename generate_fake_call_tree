#!/usr/bin/env ruby

require 'securerandom'
require 'time'

SERVICES = [
  :alpha,
  :bravo,
  :charlie,
  :delta,
  :echo,
  :foxtrot,
  :gamma,
  :hawaii,
  :indigo,
  :julia,
  :kilo,
  :oscar
]

class Span
  attr_reader :service
  attr_reader :sub_spans
  
  def initialize(service)
    @service = service
    @sub_spans = []
  end

  def span_id
    @_span_id ||= SecureRandom.uuid
  end

  def duration
    if sub_spans.empty?
      10+rand(200)
    else
      sub_span_durations = sub_spans.map(&:duration).reduce(:+)
      (sub_span_durations * duration_overhead_multiplier).to_i
    end
  end

  def add_sub_span(sub_span)
    sub_spans << sub_span
  end

  def generate_fake_log_lines(trace_id=SecureRandom.uuid, parent_span_id = '')
    # TODO: Correlation_ID
    
    log_fields = {
      traceId: trace_id,
      spanId: span_id,
      parentSpanId: parent_span_id,
      elapsedMillis: duration,
      service: service
    }
    # TODO: legit-looking timestamps
    timestamp = Time.now.iso8601

    log_line = log_fields
      .map{ |k,v| "#{k}=#{v}" }
      .unshift(timestamp)
      .join(" ")
    sub_span_log_lines = sub_spans.map{ |sub_span| sub_span.generate_fake_log_lines(trace_id,span_id) }
    sub_span_log_lines + [log_line]
  end

  def inspect(depth=0)
    sub_span_desc = sub_spans.map do |sub_span|
      sub_span.inspect(depth+1)
    end
    
    lines = [
      "#{service}: #{duration}",
      sub_span_desc
    ].flatten

    indent = "  "*depth
    lines.map{ |line| indent + line }.join("\n")
  end

  private

  def duration_overhead_multiplier
    @_duration_overhead_multiplier ||= 1.0 + (rand(100).to_f/1000)
  end
end

def remove_random_elements_from_array!(array,n)
  elements = array.sample(n)
  array.delete_if{ |x| elements.include?(x) }
  elements
end

def generate_sub_topology(available_services)
  return {} if available_services.empty?

  # choose a random number of child spans between 1 and 3
  num_child_services = 1+rand(3)
  child_services = remove_random_elements_from_array!(available_services,num_child_services)

  child_topology = {}
  child_services.each do |child_service|
    sub_topology = generate_sub_topology(available_services)
    child_topology[child_service] = sub_topology
  end

  child_topology
end  

def generate_topology
  available_services = SERVICES.dup
  {
    root_service: generate_sub_topology(available_services)
  }
end


def generate_trace_for_topology(topology)
  raise 'badly structured topology' unless topology.size == 1

  service = topology.keys.first
  sub_services = topology.values.first
  map_subtopology_to_subspan(service,sub_services)
end

def map_subtopology_to_subspan(service,sub_services)
  span = Span.new(service)
  sub_services.each do |sub_service,sub_sub_services|
    sub_span = map_subtopology_to_subspan(sub_service,sub_sub_services)
    span.add_sub_span(sub_span)
  end
  span
end

num_traces = ARGV.empty? ? 1 : (ARGV.first.to_i)

topology = generate_topology

num_traces.times do 
  trace = generate_trace_for_topology(topology)
  puts trace.generate_fake_log_lines.join("\n")
end
