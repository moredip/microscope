next up: javascript analysis



NOT HANDLED in the drilldown approach below: 
 - disconnected sub-spans (because in that case for a give trace id you'll have multiple spans with no parent span)

# DRILL DOWN 

## Service list
an overview of the average response time for each service
- for a given timerange
- bucket by service-name where parent span id is empty
- avg by elapsedMillis

# Service profile: response time distribution
a histogram summarizing the distributions of response time for a given service
- for a given timerange, service-name
- bucket by span id where service-name AND parent span id is empty (e.g. into traces)
- histogram of elapsedMillis. x is count

# Service profile: response time trend
- for a given timerange, service-name
- bucket by span id where service-name AND parent span id is empty (e.g. into traces)
- graph of elapsedMillis, x is time

# Service traces
a list of traces for a given service and response time range
- for a given timerange, service-name, and range of elapsedMillis
- bucket by span id where service-name AND parent span id is empty (e.g. into traces) AND elapsedMillis in range
- a list of matching spans. display timestamp, trace id and elapsed millis

- for a given trace ID
- the sankey diagram




HOW TO BUILD OUR SANKEY DIAGRAM
- D3's Sankey plugin wants a DAG as input (I think)
- From ES we'll get a set of log entries for a given trace ID

     - find log line where parent span id is null
     - starting there, create a root node for the DAG
 .-> - for that node, find all log lines where parentSpanId == the node
 |   - add child nodes for each log line
 `-- - for each child node...

- extra info in the DAG nodes we should pass to Sankey plugin:
  - service
  - elapsedMillis


- optimization: load all log lines into a hash keyed on parentSpanId?
